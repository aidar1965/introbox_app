// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'records_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FragmentsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FragmentsEventCopyWith<$Res> {
  factory $FragmentsEventCopyWith(
          FragmentsEvent value, $Res Function(FragmentsEvent) then) =
      _$FragmentsEventCopyWithImpl<$Res, FragmentsEvent>;
}

/// @nodoc
class _$FragmentsEventCopyWithImpl<$Res, $Val extends FragmentsEvent>
    implements $FragmentsEventCopyWith<$Res> {
  _$FragmentsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_DataRequestedCopyWith<$Res> {
  factory _$$_DataRequestedCopyWith(
          _$_DataRequested value, $Res Function(_$_DataRequested) then) =
      __$$_DataRequestedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DataRequestedCopyWithImpl<$Res>
    extends _$FragmentsEventCopyWithImpl<$Res, _$_DataRequested>
    implements _$$_DataRequestedCopyWith<$Res> {
  __$$_DataRequestedCopyWithImpl(
      _$_DataRequested _value, $Res Function(_$_DataRequested) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_DataRequested with DiagnosticableTreeMixin implements _DataRequested {
  const _$_DataRequested();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsEvent.dataRequested()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'FragmentsEvent.dataRequested'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_DataRequested);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) {
    return dataRequested();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) {
    return dataRequested?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) {
    if (dataRequested != null) {
      return dataRequested();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) {
    return dataRequested(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) {
    return dataRequested?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) {
    if (dataRequested != null) {
      return dataRequested(this);
    }
    return orElse();
  }
}

abstract class _DataRequested implements FragmentsEvent {
  const factory _DataRequested() = _$_DataRequested;
}

/// @nodoc
abstract class _$$_NewFragmentCopyWith<$Res> {
  factory _$$_NewFragmentCopyWith(
          _$_NewFragment value, $Res Function(_$_NewFragment) then) =
      __$$_NewFragmentCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NewFragmentCopyWithImpl<$Res>
    extends _$FragmentsEventCopyWithImpl<$Res, _$_NewFragment>
    implements _$$_NewFragmentCopyWith<$Res> {
  __$$_NewFragmentCopyWithImpl(
      _$_NewFragment _value, $Res Function(_$_NewFragment) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_NewFragment with DiagnosticableTreeMixin implements _NewFragment {
  const _$_NewFragment();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsEvent.newFragment()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'FragmentsEvent.newFragment'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NewFragment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) {
    return newFragment();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) {
    return newFragment?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) {
    if (newFragment != null) {
      return newFragment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) {
    return newFragment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) {
    return newFragment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) {
    if (newFragment != null) {
      return newFragment(this);
    }
    return orElse();
  }
}

abstract class _NewFragment implements FragmentsEvent {
  const factory _NewFragment() = _$_NewFragment;
}

/// @nodoc
abstract class _$$_SelectCategoryCopyWith<$Res> {
  factory _$$_SelectCategoryCopyWith(
          _$_SelectCategory value, $Res Function(_$_SelectCategory) then) =
      __$$_SelectCategoryCopyWithImpl<$Res>;
  @useResult
  $Res call({FragmentCategory category});
}

/// @nodoc
class __$$_SelectCategoryCopyWithImpl<$Res>
    extends _$FragmentsEventCopyWithImpl<$Res, _$_SelectCategory>
    implements _$$_SelectCategoryCopyWith<$Res> {
  __$$_SelectCategoryCopyWithImpl(
      _$_SelectCategory _value, $Res Function(_$_SelectCategory) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
  }) {
    return _then(_$_SelectCategory(
      null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as FragmentCategory,
    ));
  }
}

/// @nodoc

class _$_SelectCategory
    with DiagnosticableTreeMixin
    implements _SelectCategory {
  const _$_SelectCategory(this.category);

  @override
  final FragmentCategory category;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsEvent.selectCategory(category: $category)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FragmentsEvent.selectCategory'))
      ..add(DiagnosticsProperty('category', category));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SelectCategory &&
            (identical(other.category, category) ||
                other.category == category));
  }

  @override
  int get hashCode => Object.hash(runtimeType, category);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SelectCategoryCopyWith<_$_SelectCategory> get copyWith =>
      __$$_SelectCategoryCopyWithImpl<_$_SelectCategory>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) {
    return selectCategory(category);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) {
    return selectCategory?.call(category);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) {
    if (selectCategory != null) {
      return selectCategory(category);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) {
    return selectCategory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) {
    return selectCategory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) {
    if (selectCategory != null) {
      return selectCategory(this);
    }
    return orElse();
  }
}

abstract class _SelectCategory implements FragmentsEvent {
  const factory _SelectCategory(final FragmentCategory category) =
      _$_SelectCategory;

  FragmentCategory get category;
  @JsonKey(ignore: true)
  _$$_SelectCategoryCopyWith<_$_SelectCategory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_EditCategoryCopyWith<$Res> {
  factory _$$_EditCategoryCopyWith(
          _$_EditCategory value, $Res Function(_$_EditCategory) then) =
      __$$_EditCategoryCopyWithImpl<$Res>;
  @useResult
  $Res call({FragmentCategory category});
}

/// @nodoc
class __$$_EditCategoryCopyWithImpl<$Res>
    extends _$FragmentsEventCopyWithImpl<$Res, _$_EditCategory>
    implements _$$_EditCategoryCopyWith<$Res> {
  __$$_EditCategoryCopyWithImpl(
      _$_EditCategory _value, $Res Function(_$_EditCategory) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
  }) {
    return _then(_$_EditCategory(
      null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as FragmentCategory,
    ));
  }
}

/// @nodoc

class _$_EditCategory with DiagnosticableTreeMixin implements _EditCategory {
  const _$_EditCategory(this.category);

  @override
  final FragmentCategory category;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsEvent.editCategory(category: $category)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FragmentsEvent.editCategory'))
      ..add(DiagnosticsProperty('category', category));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EditCategory &&
            (identical(other.category, category) ||
                other.category == category));
  }

  @override
  int get hashCode => Object.hash(runtimeType, category);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EditCategoryCopyWith<_$_EditCategory> get copyWith =>
      __$$_EditCategoryCopyWithImpl<_$_EditCategory>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) {
    return editCategory(category);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) {
    return editCategory?.call(category);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) {
    if (editCategory != null) {
      return editCategory(category);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) {
    return editCategory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) {
    return editCategory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) {
    if (editCategory != null) {
      return editCategory(this);
    }
    return orElse();
  }
}

abstract class _EditCategory implements FragmentsEvent {
  const factory _EditCategory(final FragmentCategory category) =
      _$_EditCategory;

  FragmentCategory get category;
  @JsonKey(ignore: true)
  _$$_EditCategoryCopyWith<_$_EditCategory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_DeleteCategoryCopyWith<$Res> {
  factory _$$_DeleteCategoryCopyWith(
          _$_DeleteCategory value, $Res Function(_$_DeleteCategory) then) =
      __$$_DeleteCategoryCopyWithImpl<$Res>;
  @useResult
  $Res call({FragmentCategory category});
}

/// @nodoc
class __$$_DeleteCategoryCopyWithImpl<$Res>
    extends _$FragmentsEventCopyWithImpl<$Res, _$_DeleteCategory>
    implements _$$_DeleteCategoryCopyWith<$Res> {
  __$$_DeleteCategoryCopyWithImpl(
      _$_DeleteCategory _value, $Res Function(_$_DeleteCategory) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
  }) {
    return _then(_$_DeleteCategory(
      null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as FragmentCategory,
    ));
  }
}

/// @nodoc

class _$_DeleteCategory
    with DiagnosticableTreeMixin
    implements _DeleteCategory {
  const _$_DeleteCategory(this.category);

  @override
  final FragmentCategory category;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsEvent.deleteCategory(category: $category)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FragmentsEvent.deleteCategory'))
      ..add(DiagnosticsProperty('category', category));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DeleteCategory &&
            (identical(other.category, category) ||
                other.category == category));
  }

  @override
  int get hashCode => Object.hash(runtimeType, category);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DeleteCategoryCopyWith<_$_DeleteCategory> get copyWith =>
      __$$_DeleteCategoryCopyWithImpl<_$_DeleteCategory>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) {
    return deleteCategory(category);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) {
    return deleteCategory?.call(category);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) {
    if (deleteCategory != null) {
      return deleteCategory(category);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) {
    return deleteCategory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) {
    return deleteCategory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) {
    if (deleteCategory != null) {
      return deleteCategory(this);
    }
    return orElse();
  }
}

abstract class _DeleteCategory implements FragmentsEvent {
  const factory _DeleteCategory(final FragmentCategory category) =
      _$_DeleteCategory;

  FragmentCategory get category;
  @JsonKey(ignore: true)
  _$$_DeleteCategoryCopyWith<_$_DeleteCategory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ResendDataCopyWith<$Res> {
  factory _$$_ResendDataCopyWith(
          _$_ResendData value, $Res Function(_$_ResendData) then) =
      __$$_ResendDataCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ResendDataCopyWithImpl<$Res>
    extends _$FragmentsEventCopyWithImpl<$Res, _$_ResendData>
    implements _$$_ResendDataCopyWith<$Res> {
  __$$_ResendDataCopyWithImpl(
      _$_ResendData _value, $Res Function(_$_ResendData) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ResendData with DiagnosticableTreeMixin implements _ResendData {
  const _$_ResendData();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsEvent.resendData()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'FragmentsEvent.resendData'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ResendData);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() dataRequested,
    required TResult Function() newFragment,
    required TResult Function(FragmentCategory category) selectCategory,
    required TResult Function(FragmentCategory category) editCategory,
    required TResult Function(FragmentCategory category) deleteCategory,
    required TResult Function() resendData,
  }) {
    return resendData();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? dataRequested,
    TResult? Function()? newFragment,
    TResult? Function(FragmentCategory category)? selectCategory,
    TResult? Function(FragmentCategory category)? editCategory,
    TResult? Function(FragmentCategory category)? deleteCategory,
    TResult? Function()? resendData,
  }) {
    return resendData?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? dataRequested,
    TResult Function()? newFragment,
    TResult Function(FragmentCategory category)? selectCategory,
    TResult Function(FragmentCategory category)? editCategory,
    TResult Function(FragmentCategory category)? deleteCategory,
    TResult Function()? resendData,
    required TResult orElse(),
  }) {
    if (resendData != null) {
      return resendData();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DataRequested value) dataRequested,
    required TResult Function(_NewFragment value) newFragment,
    required TResult Function(_SelectCategory value) selectCategory,
    required TResult Function(_EditCategory value) editCategory,
    required TResult Function(_DeleteCategory value) deleteCategory,
    required TResult Function(_ResendData value) resendData,
  }) {
    return resendData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DataRequested value)? dataRequested,
    TResult? Function(_NewFragment value)? newFragment,
    TResult? Function(_SelectCategory value)? selectCategory,
    TResult? Function(_EditCategory value)? editCategory,
    TResult? Function(_DeleteCategory value)? deleteCategory,
    TResult? Function(_ResendData value)? resendData,
  }) {
    return resendData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DataRequested value)? dataRequested,
    TResult Function(_NewFragment value)? newFragment,
    TResult Function(_SelectCategory value)? selectCategory,
    TResult Function(_EditCategory value)? editCategory,
    TResult Function(_DeleteCategory value)? deleteCategory,
    TResult Function(_ResendData value)? resendData,
    required TResult orElse(),
  }) {
    if (resendData != null) {
      return resendData(this);
    }
    return orElse();
  }
}

abstract class _ResendData implements FragmentsEvent {
  const factory _ResendData() = _$_ResendData;
}

/// @nodoc
mixin _$FragmentsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function(
            List<Fragment> records,
            List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)
        dataReceived,
    required TResult Function() addFragment,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult? Function()? addFragment,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult Function()? addFragment,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Pending value) pending,
    required TResult Function(_DataReceived value) dataReceived,
    required TResult Function(_AddFragment value) addFragment,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Pending value)? pending,
    TResult? Function(_DataReceived value)? dataReceived,
    TResult? Function(_AddFragment value)? addFragment,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Pending value)? pending,
    TResult Function(_DataReceived value)? dataReceived,
    TResult Function(_AddFragment value)? addFragment,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FragmentsStateCopyWith<$Res> {
  factory $FragmentsStateCopyWith(
          FragmentsState value, $Res Function(FragmentsState) then) =
      _$FragmentsStateCopyWithImpl<$Res, FragmentsState>;
}

/// @nodoc
class _$FragmentsStateCopyWithImpl<$Res, $Val extends FragmentsState>
    implements $FragmentsStateCopyWith<$Res> {
  _$FragmentsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_PendingCopyWith<$Res> {
  factory _$$_PendingCopyWith(
          _$_Pending value, $Res Function(_$_Pending) then) =
      __$$_PendingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PendingCopyWithImpl<$Res>
    extends _$FragmentsStateCopyWithImpl<$Res, _$_Pending>
    implements _$$_PendingCopyWith<$Res> {
  __$$_PendingCopyWithImpl(_$_Pending _value, $Res Function(_$_Pending) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Pending with DiagnosticableTreeMixin implements _Pending {
  const _$_Pending();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsState.pending()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'FragmentsState.pending'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Pending);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function(
            List<Fragment> records,
            List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)
        dataReceived,
    required TResult Function() addFragment,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult? Function()? addFragment,
  }) {
    return pending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult Function()? addFragment,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Pending value) pending,
    required TResult Function(_DataReceived value) dataReceived,
    required TResult Function(_AddFragment value) addFragment,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Pending value)? pending,
    TResult? Function(_DataReceived value)? dataReceived,
    TResult? Function(_AddFragment value)? addFragment,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Pending value)? pending,
    TResult Function(_DataReceived value)? dataReceived,
    TResult Function(_AddFragment value)? addFragment,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class _Pending implements FragmentsState {
  const factory _Pending() = _$_Pending;
}

/// @nodoc
abstract class _$$_DataReceivedCopyWith<$Res> {
  factory _$$_DataReceivedCopyWith(
          _$_DataReceived value, $Res Function(_$_DataReceived) then) =
      __$$_DataReceivedCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<Fragment> records,
      List<FragmentCategory> categories,
      List<FragmentCategory> selectedCategories});
}

/// @nodoc
class __$$_DataReceivedCopyWithImpl<$Res>
    extends _$FragmentsStateCopyWithImpl<$Res, _$_DataReceived>
    implements _$$_DataReceivedCopyWith<$Res> {
  __$$_DataReceivedCopyWithImpl(
      _$_DataReceived _value, $Res Function(_$_DataReceived) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? records = null,
    Object? categories = null,
    Object? selectedCategories = null,
  }) {
    return _then(_$_DataReceived(
      records: null == records
          ? _value._records
          : records // ignore: cast_nullable_to_non_nullable
              as List<Fragment>,
      categories: null == categories
          ? _value._categories
          : categories // ignore: cast_nullable_to_non_nullable
              as List<FragmentCategory>,
      selectedCategories: null == selectedCategories
          ? _value._selectedCategories
          : selectedCategories // ignore: cast_nullable_to_non_nullable
              as List<FragmentCategory>,
    ));
  }
}

/// @nodoc

class _$_DataReceived with DiagnosticableTreeMixin implements _DataReceived {
  const _$_DataReceived(
      {required final List<Fragment> records,
      required final List<FragmentCategory> categories,
      required final List<FragmentCategory> selectedCategories})
      : _records = records,
        _categories = categories,
        _selectedCategories = selectedCategories;

  final List<Fragment> _records;
  @override
  List<Fragment> get records {
    if (_records is EqualUnmodifiableListView) return _records;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_records);
  }

  final List<FragmentCategory> _categories;
  @override
  List<FragmentCategory> get categories {
    if (_categories is EqualUnmodifiableListView) return _categories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categories);
  }

  final List<FragmentCategory> _selectedCategories;
  @override
  List<FragmentCategory> get selectedCategories {
    if (_selectedCategories is EqualUnmodifiableListView)
      return _selectedCategories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selectedCategories);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsState.dataReceived(records: $records, categories: $categories, selectedCategories: $selectedCategories)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FragmentsState.dataReceived'))
      ..add(DiagnosticsProperty('records', records))
      ..add(DiagnosticsProperty('categories', categories))
      ..add(DiagnosticsProperty('selectedCategories', selectedCategories));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DataReceived &&
            const DeepCollectionEquality().equals(other._records, _records) &&
            const DeepCollectionEquality()
                .equals(other._categories, _categories) &&
            const DeepCollectionEquality()
                .equals(other._selectedCategories, _selectedCategories));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_records),
      const DeepCollectionEquality().hash(_categories),
      const DeepCollectionEquality().hash(_selectedCategories));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DataReceivedCopyWith<_$_DataReceived> get copyWith =>
      __$$_DataReceivedCopyWithImpl<_$_DataReceived>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function(
            List<Fragment> records,
            List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)
        dataReceived,
    required TResult Function() addFragment,
  }) {
    return dataReceived(records, categories, selectedCategories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult? Function()? addFragment,
  }) {
    return dataReceived?.call(records, categories, selectedCategories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult Function()? addFragment,
    required TResult orElse(),
  }) {
    if (dataReceived != null) {
      return dataReceived(records, categories, selectedCategories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Pending value) pending,
    required TResult Function(_DataReceived value) dataReceived,
    required TResult Function(_AddFragment value) addFragment,
  }) {
    return dataReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Pending value)? pending,
    TResult? Function(_DataReceived value)? dataReceived,
    TResult? Function(_AddFragment value)? addFragment,
  }) {
    return dataReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Pending value)? pending,
    TResult Function(_DataReceived value)? dataReceived,
    TResult Function(_AddFragment value)? addFragment,
    required TResult orElse(),
  }) {
    if (dataReceived != null) {
      return dataReceived(this);
    }
    return orElse();
  }
}

abstract class _DataReceived implements FragmentsState {
  const factory _DataReceived(
          {required final List<Fragment> records,
          required final List<FragmentCategory> categories,
          required final List<FragmentCategory> selectedCategories}) =
      _$_DataReceived;

  List<Fragment> get records;
  List<FragmentCategory> get categories;
  List<FragmentCategory> get selectedCategories;
  @JsonKey(ignore: true)
  _$$_DataReceivedCopyWith<_$_DataReceived> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AddFragmentCopyWith<$Res> {
  factory _$$_AddFragmentCopyWith(
          _$_AddFragment value, $Res Function(_$_AddFragment) then) =
      __$$_AddFragmentCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AddFragmentCopyWithImpl<$Res>
    extends _$FragmentsStateCopyWithImpl<$Res, _$_AddFragment>
    implements _$$_AddFragmentCopyWith<$Res> {
  __$$_AddFragmentCopyWithImpl(
      _$_AddFragment _value, $Res Function(_$_AddFragment) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AddFragment with DiagnosticableTreeMixin implements _AddFragment {
  const _$_AddFragment();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FragmentsState.addFragment()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'FragmentsState.addFragment'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AddFragment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function(
            List<Fragment> records,
            List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)
        dataReceived,
    required TResult Function() addFragment,
  }) {
    return addFragment();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult? Function()? addFragment,
  }) {
    return addFragment?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function(List<Fragment> records, List<FragmentCategory> categories,
            List<FragmentCategory> selectedCategories)?
        dataReceived,
    TResult Function()? addFragment,
    required TResult orElse(),
  }) {
    if (addFragment != null) {
      return addFragment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Pending value) pending,
    required TResult Function(_DataReceived value) dataReceived,
    required TResult Function(_AddFragment value) addFragment,
  }) {
    return addFragment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Pending value)? pending,
    TResult? Function(_DataReceived value)? dataReceived,
    TResult? Function(_AddFragment value)? addFragment,
  }) {
    return addFragment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Pending value)? pending,
    TResult Function(_DataReceived value)? dataReceived,
    TResult Function(_AddFragment value)? addFragment,
    required TResult orElse(),
  }) {
    if (addFragment != null) {
      return addFragment(this);
    }
    return orElse();
  }
}

abstract class _AddFragment implements FragmentsState {
  const factory _AddFragment() = _$_AddFragment;
}
