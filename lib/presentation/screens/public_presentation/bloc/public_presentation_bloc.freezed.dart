// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'public_presentation_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PublicPresentationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicPresentationEventCopyWith<$Res> {
  factory $PublicPresentationEventCopyWith(PublicPresentationEvent value,
          $Res Function(PublicPresentationEvent) then) =
      _$PublicPresentationEventCopyWithImpl<$Res, PublicPresentationEvent>;
}

/// @nodoc
class _$PublicPresentationEventCopyWithImpl<$Res,
        $Val extends PublicPresentationEvent>
    implements $PublicPresentationEventCopyWith<$Res> {
  _$PublicPresentationEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_EventInitialDataRequestedCopyWith<$Res> {
  factory _$$_EventInitialDataRequestedCopyWith(
          _$_EventInitialDataRequested value,
          $Res Function(_$_EventInitialDataRequested) then) =
      __$$_EventInitialDataRequestedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EventInitialDataRequestedCopyWithImpl<$Res>
    extends _$PublicPresentationEventCopyWithImpl<$Res,
        _$_EventInitialDataRequested>
    implements _$$_EventInitialDataRequestedCopyWith<$Res> {
  __$$_EventInitialDataRequestedCopyWithImpl(
      _$_EventInitialDataRequested _value,
      $Res Function(_$_EventInitialDataRequested) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_EventInitialDataRequested
    with DiagnosticableTreeMixin
    implements _EventInitialDataRequested {
  const _$_EventInitialDataRequested();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationEvent.initialDataRequested()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'PublicPresentationEvent.initialDataRequested'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EventInitialDataRequested);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) {
    return initialDataRequested();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) {
    return initialDataRequested?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (initialDataRequested != null) {
      return initialDataRequested();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) {
    return initialDataRequested(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) {
    return initialDataRequested?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (initialDataRequested != null) {
      return initialDataRequested(this);
    }
    return orElse();
  }
}

abstract class _EventInitialDataRequested implements PublicPresentationEvent {
  const factory _EventInitialDataRequested() = _$_EventInitialDataRequested;
}

/// @nodoc
abstract class _$$_EventCheckPresentationHasPasswordCopyWith<$Res> {
  factory _$$_EventCheckPresentationHasPasswordCopyWith(
          _$_EventCheckPresentationHasPassword value,
          $Res Function(_$_EventCheckPresentationHasPassword) then) =
      __$$_EventCheckPresentationHasPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EventCheckPresentationHasPasswordCopyWithImpl<$Res>
    extends _$PublicPresentationEventCopyWithImpl<$Res,
        _$_EventCheckPresentationHasPassword>
    implements _$$_EventCheckPresentationHasPasswordCopyWith<$Res> {
  __$$_EventCheckPresentationHasPasswordCopyWithImpl(
      _$_EventCheckPresentationHasPassword _value,
      $Res Function(_$_EventCheckPresentationHasPassword) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_EventCheckPresentationHasPassword
    with DiagnosticableTreeMixin
    implements _EventCheckPresentationHasPassword {
  const _$_EventCheckPresentationHasPassword();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationEvent.checkPresentationHasPassword()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'PublicPresentationEvent.checkPresentationHasPassword'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EventCheckPresentationHasPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) {
    return checkPresentationHasPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) {
    return checkPresentationHasPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (checkPresentationHasPassword != null) {
      return checkPresentationHasPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) {
    return checkPresentationHasPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) {
    return checkPresentationHasPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (checkPresentationHasPassword != null) {
      return checkPresentationHasPassword(this);
    }
    return orElse();
  }
}

abstract class _EventCheckPresentationHasPassword
    implements PublicPresentationEvent {
  const factory _EventCheckPresentationHasPassword() =
      _$_EventCheckPresentationHasPassword;
}

/// @nodoc
abstract class _$$_EventSendPasswordCopyWith<$Res> {
  factory _$$_EventSendPasswordCopyWith(_$_EventSendPassword value,
          $Res Function(_$_EventSendPassword) then) =
      __$$_EventSendPasswordCopyWithImpl<$Res>;
  @useResult
  $Res call({String password});
}

/// @nodoc
class __$$_EventSendPasswordCopyWithImpl<$Res>
    extends _$PublicPresentationEventCopyWithImpl<$Res, _$_EventSendPassword>
    implements _$$_EventSendPasswordCopyWith<$Res> {
  __$$_EventSendPasswordCopyWithImpl(
      _$_EventSendPassword _value, $Res Function(_$_EventSendPassword) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? password = null,
  }) {
    return _then(_$_EventSendPassword(
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_EventSendPassword
    with DiagnosticableTreeMixin
    implements _EventSendPassword {
  const _$_EventSendPassword({required this.password});

  @override
  final String password;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationEvent.sendPassword(password: $password)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PublicPresentationEvent.sendPassword'))
      ..add(DiagnosticsProperty('password', password));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EventSendPassword &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @override
  int get hashCode => Object.hash(runtimeType, password);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EventSendPasswordCopyWith<_$_EventSendPassword> get copyWith =>
      __$$_EventSendPasswordCopyWithImpl<_$_EventSendPassword>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) {
    return sendPassword(password);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) {
    return sendPassword?.call(password);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (sendPassword != null) {
      return sendPassword(password);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) {
    return sendPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) {
    return sendPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (sendPassword != null) {
      return sendPassword(this);
    }
    return orElse();
  }
}

abstract class _EventSendPassword implements PublicPresentationEvent {
  const factory _EventSendPassword({required final String password}) =
      _$_EventSendPassword;

  String get password;
  @JsonKey(ignore: true)
  _$$_EventSendPasswordCopyWith<_$_EventSendPassword> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_EventNextSlideClickedCopyWith<$Res> {
  factory _$$_EventNextSlideClickedCopyWith(_$_EventNextSlideClicked value,
          $Res Function(_$_EventNextSlideClicked) then) =
      __$$_EventNextSlideClickedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EventNextSlideClickedCopyWithImpl<$Res>
    extends _$PublicPresentationEventCopyWithImpl<$Res,
        _$_EventNextSlideClicked>
    implements _$$_EventNextSlideClickedCopyWith<$Res> {
  __$$_EventNextSlideClickedCopyWithImpl(_$_EventNextSlideClicked _value,
      $Res Function(_$_EventNextSlideClicked) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_EventNextSlideClicked
    with DiagnosticableTreeMixin
    implements _EventNextSlideClicked {
  const _$_EventNextSlideClicked();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationEvent.nextSlideClicked()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'PublicPresentationEvent.nextSlideClicked'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_EventNextSlideClicked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) {
    return nextSlideClicked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) {
    return nextSlideClicked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (nextSlideClicked != null) {
      return nextSlideClicked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) {
    return nextSlideClicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) {
    return nextSlideClicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (nextSlideClicked != null) {
      return nextSlideClicked(this);
    }
    return orElse();
  }
}

abstract class _EventNextSlideClicked implements PublicPresentationEvent {
  const factory _EventNextSlideClicked() = _$_EventNextSlideClicked;
}

/// @nodoc
abstract class _$$_EventPreviousSlideClickedCopyWith<$Res> {
  factory _$$_EventPreviousSlideClickedCopyWith(
          _$_EventPreviousSlideClicked value,
          $Res Function(_$_EventPreviousSlideClicked) then) =
      __$$_EventPreviousSlideClickedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EventPreviousSlideClickedCopyWithImpl<$Res>
    extends _$PublicPresentationEventCopyWithImpl<$Res,
        _$_EventPreviousSlideClicked>
    implements _$$_EventPreviousSlideClickedCopyWith<$Res> {
  __$$_EventPreviousSlideClickedCopyWithImpl(
      _$_EventPreviousSlideClicked _value,
      $Res Function(_$_EventPreviousSlideClicked) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_EventPreviousSlideClicked
    with DiagnosticableTreeMixin
    implements _EventPreviousSlideClicked {
  const _$_EventPreviousSlideClicked();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationEvent.previousSlideClicked()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'PublicPresentationEvent.previousSlideClicked'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EventPreviousSlideClicked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) {
    return previousSlideClicked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) {
    return previousSlideClicked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (previousSlideClicked != null) {
      return previousSlideClicked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) {
    return previousSlideClicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) {
    return previousSlideClicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (previousSlideClicked != null) {
      return previousSlideClicked(this);
    }
    return orElse();
  }
}

abstract class _EventPreviousSlideClicked implements PublicPresentationEvent {
  const factory _EventPreviousSlideClicked() = _$_EventPreviousSlideClicked;
}

/// @nodoc
abstract class _$$_EventFragmentClickedCopyWith<$Res> {
  factory _$$_EventFragmentClickedCopyWith(_$_EventFragmentClicked value,
          $Res Function(_$_EventFragmentClicked) then) =
      __$$_EventFragmentClickedCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$_EventFragmentClickedCopyWithImpl<$Res>
    extends _$PublicPresentationEventCopyWithImpl<$Res, _$_EventFragmentClicked>
    implements _$$_EventFragmentClickedCopyWith<$Res> {
  __$$_EventFragmentClickedCopyWithImpl(_$_EventFragmentClicked _value,
      $Res Function(_$_EventFragmentClicked) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$_EventFragmentClicked(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_EventFragmentClicked
    with DiagnosticableTreeMixin
    implements _EventFragmentClicked {
  const _$_EventFragmentClicked(this.index);

  @override
  final int index;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationEvent.fragmentClicked(index: $index)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'PublicPresentationEvent.fragmentClicked'))
      ..add(DiagnosticsProperty('index', index));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EventFragmentClicked &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EventFragmentClickedCopyWith<_$_EventFragmentClicked> get copyWith =>
      __$$_EventFragmentClickedCopyWithImpl<_$_EventFragmentClicked>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialDataRequested,
    required TResult Function() checkPresentationHasPassword,
    required TResult Function(String password) sendPassword,
    required TResult Function() nextSlideClicked,
    required TResult Function() previousSlideClicked,
    required TResult Function(int index) fragmentClicked,
  }) {
    return fragmentClicked(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialDataRequested,
    TResult? Function()? checkPresentationHasPassword,
    TResult? Function(String password)? sendPassword,
    TResult? Function()? nextSlideClicked,
    TResult? Function()? previousSlideClicked,
    TResult? Function(int index)? fragmentClicked,
  }) {
    return fragmentClicked?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialDataRequested,
    TResult Function()? checkPresentationHasPassword,
    TResult Function(String password)? sendPassword,
    TResult Function()? nextSlideClicked,
    TResult Function()? previousSlideClicked,
    TResult Function(int index)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (fragmentClicked != null) {
      return fragmentClicked(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_EventInitialDataRequested value)
        initialDataRequested,
    required TResult Function(_EventCheckPresentationHasPassword value)
        checkPresentationHasPassword,
    required TResult Function(_EventSendPassword value) sendPassword,
    required TResult Function(_EventNextSlideClicked value) nextSlideClicked,
    required TResult Function(_EventPreviousSlideClicked value)
        previousSlideClicked,
    required TResult Function(_EventFragmentClicked value) fragmentClicked,
  }) {
    return fragmentClicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult? Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult? Function(_EventSendPassword value)? sendPassword,
    TResult? Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult? Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult? Function(_EventFragmentClicked value)? fragmentClicked,
  }) {
    return fragmentClicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_EventInitialDataRequested value)? initialDataRequested,
    TResult Function(_EventCheckPresentationHasPassword value)?
        checkPresentationHasPassword,
    TResult Function(_EventSendPassword value)? sendPassword,
    TResult Function(_EventNextSlideClicked value)? nextSlideClicked,
    TResult Function(_EventPreviousSlideClicked value)? previousSlideClicked,
    TResult Function(_EventFragmentClicked value)? fragmentClicked,
    required TResult orElse(),
  }) {
    if (fragmentClicked != null) {
      return fragmentClicked(this);
    }
    return orElse();
  }
}

abstract class _EventFragmentClicked implements PublicPresentationEvent {
  const factory _EventFragmentClicked(final int index) =
      _$_EventFragmentClicked;

  int get index;
  @JsonKey(ignore: true)
  _$$_EventFragmentClickedCopyWith<_$_EventFragmentClicked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PublicPresentationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicPresentationStateCopyWith<$Res> {
  factory $PublicPresentationStateCopyWith(PublicPresentationState value,
          $Res Function(PublicPresentationState) then) =
      _$PublicPresentationStateCopyWithImpl<$Res, PublicPresentationState>;
}

/// @nodoc
class _$PublicPresentationStateCopyWithImpl<$Res,
        $Val extends PublicPresentationState>
    implements $PublicPresentationStateCopyWith<$Res> {
  _$PublicPresentationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_ScreenStateCopyWith<$Res> {
  factory _$$_ScreenStateCopyWith(
          _$_ScreenState value, $Res Function(_$_ScreenState) then) =
      __$$_ScreenStateCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PdfFragment? selectedFragment,
      bool isLast,
      bool isFirst,
      String presentationTitle,
      String? presentationDescription,
      String? pdfFile,
      List<PdfFragment> fragments,
      Channel? channel,
      bool isAuthorized,
      Uint8List? preloadedImage,
      List<PresentationLink>? links});
}

/// @nodoc
class __$$_ScreenStateCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_ScreenState>
    implements _$$_ScreenStateCopyWith<$Res> {
  __$$_ScreenStateCopyWithImpl(
      _$_ScreenState _value, $Res Function(_$_ScreenState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedFragment = freezed,
    Object? isLast = null,
    Object? isFirst = null,
    Object? presentationTitle = null,
    Object? presentationDescription = freezed,
    Object? pdfFile = freezed,
    Object? fragments = null,
    Object? channel = freezed,
    Object? isAuthorized = null,
    Object? preloadedImage = freezed,
    Object? links = freezed,
  }) {
    return _then(_$_ScreenState(
      selectedFragment: freezed == selectedFragment
          ? _value.selectedFragment
          : selectedFragment // ignore: cast_nullable_to_non_nullable
              as PdfFragment?,
      isLast: null == isLast
          ? _value.isLast
          : isLast // ignore: cast_nullable_to_non_nullable
              as bool,
      isFirst: null == isFirst
          ? _value.isFirst
          : isFirst // ignore: cast_nullable_to_non_nullable
              as bool,
      presentationTitle: null == presentationTitle
          ? _value.presentationTitle
          : presentationTitle // ignore: cast_nullable_to_non_nullable
              as String,
      presentationDescription: freezed == presentationDescription
          ? _value.presentationDescription
          : presentationDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      pdfFile: freezed == pdfFile
          ? _value.pdfFile
          : pdfFile // ignore: cast_nullable_to_non_nullable
              as String?,
      fragments: null == fragments
          ? _value._fragments
          : fragments // ignore: cast_nullable_to_non_nullable
              as List<PdfFragment>,
      channel: freezed == channel
          ? _value.channel
          : channel // ignore: cast_nullable_to_non_nullable
              as Channel?,
      isAuthorized: null == isAuthorized
          ? _value.isAuthorized
          : isAuthorized // ignore: cast_nullable_to_non_nullable
              as bool,
      preloadedImage: freezed == preloadedImage
          ? _value.preloadedImage
          : preloadedImage // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      links: freezed == links
          ? _value._links
          : links // ignore: cast_nullable_to_non_nullable
              as List<PresentationLink>?,
    ));
  }
}

/// @nodoc

class _$_ScreenState with DiagnosticableTreeMixin implements _ScreenState {
  const _$_ScreenState(
      {this.selectedFragment,
      required this.isLast,
      required this.isFirst,
      required this.presentationTitle,
      this.presentationDescription,
      this.pdfFile,
      required final List<PdfFragment> fragments,
      required this.channel,
      required this.isAuthorized,
      this.preloadedImage,
      final List<PresentationLink>? links})
      : _fragments = fragments,
        _links = links;

  @override
  final PdfFragment? selectedFragment;
  @override
  final bool isLast;
  @override
  final bool isFirst;
  @override
  final String presentationTitle;
  @override
  final String? presentationDescription;
  @override
  final String? pdfFile;
  final List<PdfFragment> _fragments;
  @override
  List<PdfFragment> get fragments {
    if (_fragments is EqualUnmodifiableListView) return _fragments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fragments);
  }

  @override
  final Channel? channel;
  @override
  final bool isAuthorized;
  @override
  final Uint8List? preloadedImage;
  final List<PresentationLink>? _links;
  @override
  List<PresentationLink>? get links {
    final value = _links;
    if (value == null) return null;
    if (_links is EqualUnmodifiableListView) return _links;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.screenState(selectedFragment: $selectedFragment, isLast: $isLast, isFirst: $isFirst, presentationTitle: $presentationTitle, presentationDescription: $presentationDescription, pdfFile: $pdfFile, fragments: $fragments, channel: $channel, isAuthorized: $isAuthorized, preloadedImage: $preloadedImage, links: $links)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PublicPresentationState.screenState'))
      ..add(DiagnosticsProperty('selectedFragment', selectedFragment))
      ..add(DiagnosticsProperty('isLast', isLast))
      ..add(DiagnosticsProperty('isFirst', isFirst))
      ..add(DiagnosticsProperty('presentationTitle', presentationTitle))
      ..add(DiagnosticsProperty(
          'presentationDescription', presentationDescription))
      ..add(DiagnosticsProperty('pdfFile', pdfFile))
      ..add(DiagnosticsProperty('fragments', fragments))
      ..add(DiagnosticsProperty('channel', channel))
      ..add(DiagnosticsProperty('isAuthorized', isAuthorized))
      ..add(DiagnosticsProperty('preloadedImage', preloadedImage))
      ..add(DiagnosticsProperty('links', links));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ScreenState &&
            (identical(other.selectedFragment, selectedFragment) ||
                other.selectedFragment == selectedFragment) &&
            (identical(other.isLast, isLast) || other.isLast == isLast) &&
            (identical(other.isFirst, isFirst) || other.isFirst == isFirst) &&
            (identical(other.presentationTitle, presentationTitle) ||
                other.presentationTitle == presentationTitle) &&
            (identical(
                    other.presentationDescription, presentationDescription) ||
                other.presentationDescription == presentationDescription) &&
            (identical(other.pdfFile, pdfFile) || other.pdfFile == pdfFile) &&
            const DeepCollectionEquality()
                .equals(other._fragments, _fragments) &&
            (identical(other.channel, channel) || other.channel == channel) &&
            (identical(other.isAuthorized, isAuthorized) ||
                other.isAuthorized == isAuthorized) &&
            const DeepCollectionEquality()
                .equals(other.preloadedImage, preloadedImage) &&
            const DeepCollectionEquality().equals(other._links, _links));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      selectedFragment,
      isLast,
      isFirst,
      presentationTitle,
      presentationDescription,
      pdfFile,
      const DeepCollectionEquality().hash(_fragments),
      channel,
      isAuthorized,
      const DeepCollectionEquality().hash(preloadedImage),
      const DeepCollectionEquality().hash(_links));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ScreenStateCopyWith<_$_ScreenState> get copyWith =>
      __$$_ScreenStateCopyWithImpl<_$_ScreenState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return screenState(
        selectedFragment,
        isLast,
        isFirst,
        presentationTitle,
        presentationDescription,
        pdfFile,
        fragments,
        channel,
        isAuthorized,
        preloadedImage,
        links);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return screenState?.call(
        selectedFragment,
        isLast,
        isFirst,
        presentationTitle,
        presentationDescription,
        pdfFile,
        fragments,
        channel,
        isAuthorized,
        preloadedImage,
        links);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (screenState != null) {
      return screenState(
          selectedFragment,
          isLast,
          isFirst,
          presentationTitle,
          presentationDescription,
          pdfFile,
          fragments,
          channel,
          isAuthorized,
          preloadedImage,
          links);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return screenState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return screenState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (screenState != null) {
      return screenState(this);
    }
    return orElse();
  }
}

abstract class _ScreenState implements PublicPresentationState {
  const factory _ScreenState(
      {final PdfFragment? selectedFragment,
      required final bool isLast,
      required final bool isFirst,
      required final String presentationTitle,
      final String? presentationDescription,
      final String? pdfFile,
      required final List<PdfFragment> fragments,
      required final Channel? channel,
      required final bool isAuthorized,
      final Uint8List? preloadedImage,
      final List<PresentationLink>? links}) = _$_ScreenState;

  PdfFragment? get selectedFragment;
  bool get isLast;
  bool get isFirst;
  String get presentationTitle;
  String? get presentationDescription;
  String? get pdfFile;
  List<PdfFragment> get fragments;
  Channel? get channel;
  bool get isAuthorized;
  Uint8List? get preloadedImage;
  List<PresentationLink>? get links;
  @JsonKey(ignore: true)
  _$$_ScreenStateCopyWith<_$_ScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StatePasswordFormCopyWith<$Res> {
  factory _$$_StatePasswordFormCopyWith(_$_StatePasswordForm value,
          $Res Function(_$_StatePasswordForm) then) =
      __$$_StatePasswordFormCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isPending});
}

/// @nodoc
class __$$_StatePasswordFormCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_StatePasswordForm>
    implements _$$_StatePasswordFormCopyWith<$Res> {
  __$$_StatePasswordFormCopyWithImpl(
      _$_StatePasswordForm _value, $Res Function(_$_StatePasswordForm) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isPending = null,
  }) {
    return _then(_$_StatePasswordForm(
      isPending: null == isPending
          ? _value.isPending
          : isPending // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_StatePasswordForm
    with DiagnosticableTreeMixin
    implements _StatePasswordForm {
  const _$_StatePasswordForm({this.isPending = false});

  @override
  @JsonKey()
  final bool isPending;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.passwordForm(isPending: $isPending)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PublicPresentationState.passwordForm'))
      ..add(DiagnosticsProperty('isPending', isPending));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StatePasswordForm &&
            (identical(other.isPending, isPending) ||
                other.isPending == isPending));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isPending);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StatePasswordFormCopyWith<_$_StatePasswordForm> get copyWith =>
      __$$_StatePasswordFormCopyWithImpl<_$_StatePasswordForm>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return passwordForm(isPending);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return passwordForm?.call(isPending);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (passwordForm != null) {
      return passwordForm(isPending);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return passwordForm(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return passwordForm?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (passwordForm != null) {
      return passwordForm(this);
    }
    return orElse();
  }
}

abstract class _StatePasswordForm implements PublicPresentationState {
  const factory _StatePasswordForm({final bool isPending}) =
      _$_StatePasswordForm;

  bool get isPending;
  @JsonKey(ignore: true)
  _$$_StatePasswordFormCopyWith<_$_StatePasswordForm> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StateLoadingErrorCopyWith<$Res> {
  factory _$$_StateLoadingErrorCopyWith(_$_StateLoadingError value,
          $Res Function(_$_StateLoadingError) then) =
      __$$_StateLoadingErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isPending});
}

/// @nodoc
class __$$_StateLoadingErrorCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_StateLoadingError>
    implements _$$_StateLoadingErrorCopyWith<$Res> {
  __$$_StateLoadingErrorCopyWithImpl(
      _$_StateLoadingError _value, $Res Function(_$_StateLoadingError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isPending = null,
  }) {
    return _then(_$_StateLoadingError(
      isPending: null == isPending
          ? _value.isPending
          : isPending // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_StateLoadingError
    with DiagnosticableTreeMixin
    implements _StateLoadingError {
  const _$_StateLoadingError({this.isPending = false});

  @override
  @JsonKey()
  final bool isPending;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.loadingError(isPending: $isPending)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PublicPresentationState.loadingError'))
      ..add(DiagnosticsProperty('isPending', isPending));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StateLoadingError &&
            (identical(other.isPending, isPending) ||
                other.isPending == isPending));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isPending);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StateLoadingErrorCopyWith<_$_StateLoadingError> get copyWith =>
      __$$_StateLoadingErrorCopyWithImpl<_$_StateLoadingError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return loadingError(isPending);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return loadingError?.call(isPending);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (loadingError != null) {
      return loadingError(isPending);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return loadingError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return loadingError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (loadingError != null) {
      return loadingError(this);
    }
    return orElse();
  }
}

abstract class _StateLoadingError implements PublicPresentationState {
  const factory _StateLoadingError({final bool isPending}) =
      _$_StateLoadingError;

  bool get isPending;
  @JsonKey(ignore: true)
  _$$_StateLoadingErrorCopyWith<_$_StateLoadingError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StateCheckHasPasswordErrorCopyWith<$Res> {
  factory _$$_StateCheckHasPasswordErrorCopyWith(
          _$_StateCheckHasPasswordError value,
          $Res Function(_$_StateCheckHasPasswordError) then) =
      __$$_StateCheckHasPasswordErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isPending});
}

/// @nodoc
class __$$_StateCheckHasPasswordErrorCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res,
        _$_StateCheckHasPasswordError>
    implements _$$_StateCheckHasPasswordErrorCopyWith<$Res> {
  __$$_StateCheckHasPasswordErrorCopyWithImpl(
      _$_StateCheckHasPasswordError _value,
      $Res Function(_$_StateCheckHasPasswordError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isPending = null,
  }) {
    return _then(_$_StateCheckHasPasswordError(
      isPending: null == isPending
          ? _value.isPending
          : isPending // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_StateCheckHasPasswordError
    with DiagnosticableTreeMixin
    implements _StateCheckHasPasswordError {
  const _$_StateCheckHasPasswordError({this.isPending = false});

  @override
  @JsonKey()
  final bool isPending;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.checkHasPasswordError(isPending: $isPending)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'PublicPresentationState.checkHasPasswordError'))
      ..add(DiagnosticsProperty('isPending', isPending));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StateCheckHasPasswordError &&
            (identical(other.isPending, isPending) ||
                other.isPending == isPending));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isPending);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StateCheckHasPasswordErrorCopyWith<_$_StateCheckHasPasswordError>
      get copyWith => __$$_StateCheckHasPasswordErrorCopyWithImpl<
          _$_StateCheckHasPasswordError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return checkHasPasswordError(isPending);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return checkHasPasswordError?.call(isPending);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (checkHasPasswordError != null) {
      return checkHasPasswordError(isPending);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return checkHasPasswordError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return checkHasPasswordError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (checkHasPasswordError != null) {
      return checkHasPasswordError(this);
    }
    return orElse();
  }
}

abstract class _StateCheckHasPasswordError implements PublicPresentationState {
  const factory _StateCheckHasPasswordError({final bool isPending}) =
      _$_StateCheckHasPasswordError;

  bool get isPending;
  @JsonKey(ignore: true)
  _$$_StateCheckHasPasswordErrorCopyWith<_$_StateCheckHasPasswordError>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StatePendingCopyWith<$Res> {
  factory _$$_StatePendingCopyWith(
          _$_StatePending value, $Res Function(_$_StatePending) then) =
      __$$_StatePendingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StatePendingCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_StatePending>
    implements _$$_StatePendingCopyWith<$Res> {
  __$$_StatePendingCopyWithImpl(
      _$_StatePending _value, $Res Function(_$_StatePending) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StatePending with DiagnosticableTreeMixin implements _StatePending {
  const _$_StatePending();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.pending()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'PublicPresentationState.pending'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StatePending);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return pending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class _StatePending implements PublicPresentationState {
  const factory _StatePending() = _$_StatePending;
}

/// @nodoc
abstract class _$$_StateIdNotSpecifiedCopyWith<$Res> {
  factory _$$_StateIdNotSpecifiedCopyWith(_$_StateIdNotSpecified value,
          $Res Function(_$_StateIdNotSpecified) then) =
      __$$_StateIdNotSpecifiedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StateIdNotSpecifiedCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_StateIdNotSpecified>
    implements _$$_StateIdNotSpecifiedCopyWith<$Res> {
  __$$_StateIdNotSpecifiedCopyWithImpl(_$_StateIdNotSpecified _value,
      $Res Function(_$_StateIdNotSpecified) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StateIdNotSpecified
    with DiagnosticableTreeMixin
    implements _StateIdNotSpecified {
  const _$_StateIdNotSpecified();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.idNotSpecified()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'PublicPresentationState.idNotSpecified'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StateIdNotSpecified);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return idNotSpecified();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return idNotSpecified?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (idNotSpecified != null) {
      return idNotSpecified();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return idNotSpecified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return idNotSpecified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (idNotSpecified != null) {
      return idNotSpecified(this);
    }
    return orElse();
  }
}

abstract class _StateIdNotSpecified implements PublicPresentationState {
  const factory _StateIdNotSpecified() = _$_StateIdNotSpecified;
}

/// @nodoc
abstract class _$$_StateRequestErrorCopyWith<$Res> {
  factory _$$_StateRequestErrorCopyWith(_$_StateRequestError value,
          $Res Function(_$_StateRequestError) then) =
      __$$_StateRequestErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String? errorText});
}

/// @nodoc
class __$$_StateRequestErrorCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_StateRequestError>
    implements _$$_StateRequestErrorCopyWith<$Res> {
  __$$_StateRequestErrorCopyWithImpl(
      _$_StateRequestError _value, $Res Function(_$_StateRequestError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorText = freezed,
  }) {
    return _then(_$_StateRequestError(
      errorText: freezed == errorText
          ? _value.errorText
          : errorText // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_StateRequestError
    with DiagnosticableTreeMixin
    implements _StateRequestError {
  const _$_StateRequestError({this.errorText});

  @override
  final String? errorText;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.requestError(errorText: $errorText)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PublicPresentationState.requestError'))
      ..add(DiagnosticsProperty('errorText', errorText));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StateRequestError &&
            (identical(other.errorText, errorText) ||
                other.errorText == errorText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StateRequestErrorCopyWith<_$_StateRequestError> get copyWith =>
      __$$_StateRequestErrorCopyWithImpl<_$_StateRequestError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return requestError(errorText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return requestError?.call(errorText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (requestError != null) {
      return requestError(errorText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return requestError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return requestError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (requestError != null) {
      return requestError(this);
    }
    return orElse();
  }
}

abstract class _StateRequestError implements PublicPresentationState {
  const factory _StateRequestError({final String? errorText}) =
      _$_StateRequestError;

  String? get errorText;
  @JsonKey(ignore: true)
  _$$_StateRequestErrorCopyWith<_$_StateRequestError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StateNotFoundCopyWith<$Res> {
  factory _$$_StateNotFoundCopyWith(
          _$_StateNotFound value, $Res Function(_$_StateNotFound) then) =
      __$$_StateNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StateNotFoundCopyWithImpl<$Res>
    extends _$PublicPresentationStateCopyWithImpl<$Res, _$_StateNotFound>
    implements _$$_StateNotFoundCopyWith<$Res> {
  __$$_StateNotFoundCopyWithImpl(
      _$_StateNotFound _value, $Res Function(_$_StateNotFound) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StateNotFound with DiagnosticableTreeMixin implements _StateNotFound {
  const _$_StateNotFound();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PublicPresentationState.notFound()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'PublicPresentationState.notFound'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StateNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)
        screenState,
    required TResult Function(bool isPending) passwordForm,
    required TResult Function(bool isPending) loadingError,
    required TResult Function(bool isPending) checkHasPasswordError,
    required TResult Function() pending,
    required TResult Function() idNotSpecified,
    required TResult Function(String? errorText) requestError,
    required TResult Function() notFound,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult? Function(bool isPending)? passwordForm,
    TResult? Function(bool isPending)? loadingError,
    TResult? Function(bool isPending)? checkHasPasswordError,
    TResult? Function()? pending,
    TResult? Function()? idNotSpecified,
    TResult? Function(String? errorText)? requestError,
    TResult? Function()? notFound,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PdfFragment? selectedFragment,
            bool isLast,
            bool isFirst,
            String presentationTitle,
            String? presentationDescription,
            String? pdfFile,
            List<PdfFragment> fragments,
            Channel? channel,
            bool isAuthorized,
            Uint8List? preloadedImage,
            List<PresentationLink>? links)?
        screenState,
    TResult Function(bool isPending)? passwordForm,
    TResult Function(bool isPending)? loadingError,
    TResult Function(bool isPending)? checkHasPasswordError,
    TResult Function()? pending,
    TResult Function()? idNotSpecified,
    TResult Function(String? errorText)? requestError,
    TResult Function()? notFound,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ScreenState value) screenState,
    required TResult Function(_StatePasswordForm value) passwordForm,
    required TResult Function(_StateLoadingError value) loadingError,
    required TResult Function(_StateCheckHasPasswordError value)
        checkHasPasswordError,
    required TResult Function(_StatePending value) pending,
    required TResult Function(_StateIdNotSpecified value) idNotSpecified,
    required TResult Function(_StateRequestError value) requestError,
    required TResult Function(_StateNotFound value) notFound,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ScreenState value)? screenState,
    TResult? Function(_StatePasswordForm value)? passwordForm,
    TResult? Function(_StateLoadingError value)? loadingError,
    TResult? Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult? Function(_StatePending value)? pending,
    TResult? Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult? Function(_StateRequestError value)? requestError,
    TResult? Function(_StateNotFound value)? notFound,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ScreenState value)? screenState,
    TResult Function(_StatePasswordForm value)? passwordForm,
    TResult Function(_StateLoadingError value)? loadingError,
    TResult Function(_StateCheckHasPasswordError value)? checkHasPasswordError,
    TResult Function(_StatePending value)? pending,
    TResult Function(_StateIdNotSpecified value)? idNotSpecified,
    TResult Function(_StateRequestError value)? requestError,
    TResult Function(_StateNotFound value)? notFound,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _StateNotFound implements PublicPresentationState {
  const factory _StateNotFound() = _$_StateNotFound;
}
